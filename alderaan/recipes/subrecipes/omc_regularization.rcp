import os
import sys
import warnings

from astropy.stats import mad_std
from copy import deepcopy
import numpy as np

from alderaan.modules.omc import OMC
from alderaan.modules.quicklook import plot_omc
from alderaan.utils.io import save_omc_ephemeris


def run(context, check_periodic=True):
    print('\n\nSUBRECIPE: REGULARIZE OMC\n')

    # infer context
    NPL = context.NPL
    target = context.target
    planets = context.planets

    # initialize OMC object and ttv_buffer tracker for each planet
    omc_list = []
    for n, p in enumerate(planets):
        omc_list.append(OMC(p.ephemeris))

    ttv_buffer = np.zeros(NPL, dtype=float)

    # search for period signals
    if check_periodic:
        print("searching for periodic signals")
        if NPL == 1:
            critical_fap = 0.1
        elif NPL > 1:
            critical_fap = 0.99

        freq = [None]*NPL
        fap = [None]*NPL

        for n, p in enumerate(planets):
            freq[n], fap[n] = omc_list[n].identify_significant_frequencies(critical_fap)

        # single planet systems : use direct search output (FAP < 0.1)
        if NPL == 1:
            pass

        # multiplanet systems : compare marginal frequencies to find close matches
        if NPL > 1:
            close = np.zeros((NPL,NPL), dtype=bool)

            for i in range(NPL):
                df_min = 1 / (planets[i].ephemeris.ttime.max() - planets[i].ephemeris.ttime.min())
                
                for j in range(i+1, NPL):
                    if freq[i] is not None and freq[j] is not None:
                        df_ij = np.abs(freq[i] - freq[j])
                        
                        if df_ij < df_min:
                            close[i,j] = True
                            close[j,i] = True

            for i in range(NPL):
                if fap[i] is not None:
                    if not np.any(close[i]) and fap[i] > 0.1:
                        freq[i] = None
                        fap[i] = None

        for n, p in enumerate(planets):
            if freq[n] is not None:
                print(f"  Planet {n} : periodic signal found at P = {1/freq[n]:.1f} days")
            else:
                print(f"  Planet {n} : no significant periodic component found")


    # fit a regularized model
    for n, p in enumerate(planets):
        omc = omc_list[n]
        npts = np.sum(omc.quality)
        old_ephemeris = deepcopy(p.ephemeris)

        print(f"\nperforming omc model selection for Planet {n} ({npts} transits)")

        traces = {}
        dofs = {}

        # Matern-3/2 model | don't use GP on very noisy data
        if (npts >= 8) & (np.median(omc.yerr) <= 0.5 * mad_std(omc.yobs)):
            print("\nmatern-3/2 model")
            with warnings.catch_warnings(record=True) as catch:
                warnings.simplefilter('always', category=RuntimeWarning)
                traces['matern32'] = omc.sample(omc.matern32_model())
                dofs['matern32'] = np.nanmedian(traces['matern32']['dof'])

        # Polynomial model | require 2^N transits, at most do 3rd order
        max_polyorder = np.max([1, np.min([3, int(np.log2(npts))-1])])
        for polyorder in range(1, max_polyorder+1):
            print(f"\npolynomial (degree {polyorder}) model")
            with warnings.catch_warnings(record=True) as catch:
                warnings.simplefilter('always', category=RuntimeWarning)
                traces[f'poly_{polyorder}'] = omc.sample(omc.poly_model(polyorder))
                dofs[f'poly_{polyorder}'] = 1 + polyorder

        # Sinusoidal model 
        if check_periodic and npts >= 8 and freq[n] is not None:
            print("\nsinusoid model")
            with warnings.catch_warnings(record=True) as catch:
                warnings.simplefilter('always', category=RuntimeWarning)
                traces['sinusoid'] = omc.sample(omc.sin_model(ttv_period=1/freq[n]))
                dofs['sinusoid'] = 3
        
        if len(catch) > 0:
            print(f"{len(catch)} RuntimeWarnings caught during sampling")

        # perform model selection routine and update objects
        omc.ymod, best_omc_model_name = omc.select_best_model(traces, dofs)
        print(f"\nPlanet {n} : adopting {best_omc_model_name} as omc model and flagging outliers")
        
        omc.out_prob, omc.out_class = omc.calculate_outlier_probability(omc.ymod)

        _filename = os.path.join(context.results_dir, f'{target}_{n:02d}_quick.ttvs')
        save_omc_ephemeris(_filename, omc)

        new_ephemeris = p.ephemeris.update_from_omc(omc).interpolate(full=True)
        
        planets[n] = p.update_ephemeris(new_ephemeris)
        print(f"Planet {n} : {old_ephemeris.period:.6f} --> {new_ephemeris.period:.6f}")

    # make quicklook plot and return planets
    _filepath = os.path.join(context.quicklook_dir, f"{target}_omc.png")
    _ = plot_omc(omc_list, target, _filepath)

    return {'planets': planets}
