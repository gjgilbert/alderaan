import os
import sys
import warnings

from copy import deepcopy
import numpy as np
from alderaan.modules.transit import CrossCorrelationTTVModel, TTVTransitModel

def run(context):
    print('\n\nSUBRECIPE: QUICK FIT TRANSIT TIMES\n')

    # infer context
    NPL = context.NPL
    planets = context.planets
    litecurve = context.litecurve
    limbdark = context.limbdark

    # fit transit times using Mazeh+13 / Holczer+16 cross-correlation method
    ttvmodel = CrossCorrelationTTVModel(litecurve, planets, limbdark)

    for n, p in enumerate(planets):
        print(f"\nPlanet {n} : fitting {np.sum(p.ephemeris.quality)} transit times")

        ttime_old, ttime_err_old = p.ephemeris.ttime, p.ephemeris.error
        ttime_new, ttime_err_new = ttvmodel.mazeh13_holczer16_method(n, target=context.target, quicklook_dir=context.quicklook_dir)

        assert len(ttime_new) == len(ttime_old)
        assert len(ttime_err_new) == len(ttime_err_old)

        _nfit = np.sum(~np.isnan(ttime_new))
        _ntot = np.sum(p.ephemeris.quality)

        print(f"Planet {n} : {_nfit} of {_ntot} transit times ({_nfit / _ntot * 100:.1f}%) fit successfully")
        
        q = ~np.isnan(ttime_new) & ~np.isnan(ttime_err_new)
        p.ephemeris.ttime[q] = ttime_new[q]
        p.ephemeris.error[q] = ttime_err_new[q]
        planets[n] = p.update_ephemeris(p.ephemeris)
        #p.ephemeris = p.ephemeris.interpolate(full=False, reset_quality=False)

    # fit transit times using least squares optimization
    print("\nOptimizing independent transit times")
    old_ephemerides = [None]*NPL
    for n, p in enumerate(planets):
        old_ephemerides[n] = deepcopy(p.ephemeris)

    ttvmodel = TTVTransitModel(litecurve, planets, limbdark)
    theta = ttvmodel.optimize()
    planets = ttvmodel.update_transit_times(theta)

    # prioritize cross-correlation transit times
    for n, p in enumerate(planets):
        old_ephem = old_ephemerides[n]
        new_ephem = p.ephemeris

        new_ephem.ttime[old_ephem.quality] = old_ephem.ttime[old_ephem.quality]
        new_ephem.error[old_ephem.quality] = old_ephem.error[old_ephem.quality]
        new_ephem.quality = np.ones(len(new_ephem.ttime), dtype=bool)

        planets[n] = p.update_ephemeris(new_ephem)

    return {'planets': planets}